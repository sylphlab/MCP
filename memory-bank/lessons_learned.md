# Lessons Learned

*   **[2025-04-20] Vitest Mocking & Hoisting:** When using `vi.mock`, ensure that variables referenced within the mock factory are defined *before* the `vi.mock` call itself to avoid hoisting-related `ReferenceError`s. A robust pattern involves defining the mock variable, calling `vi.mock` referencing that variable, and then setting the mock implementation *after* `vi.mock` but *before* importing the module under test. Alternatively, using dynamic `await import()` *after* `vi.mock` can also resolve complex timing issues, but ensure variables assigned within `beforeEach` are declared with `let` in the `describe` scope.
*   **[2025-04-20] Vitest State Leakage:** Module-level caching or state can cause unexpected interactions between tests. Use `vi.resetModules()` within `beforeEach` (before any dynamic imports) to ensure a fresh module state for each test, preventing state leakage.
*   **[2025-04-20] Vitest `--passWithNoTests`:** When a package intentionally has no tests, the `vitest run` command will fail by default. Add the `--passWithNoTests` flag to the corresponding `test` script in `package.json` to allow the command to succeed in this scenario.
*   **[2025-04-20] Test Error Diagnosis:** When tests fail with unexpected errors (e.g., promise resolving instead of rejecting, or unexpected error types), carefully examine mock setups, test isolation (state leakage), and the error handling logic within the source code being tested. Assertions might need adjustment (`expect.any(TypeError)` vs specific error object) if internal error handling masks the originally thrown error.